Ruby is a dynamic, open source, object oriented and reflective programming language. It is fully object oriented programming language. Everything is an object in Ruby.

** Installation of RVM **
1. Open your linux terminal and use the following commands.
    a) gpg2 --keyserver keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
    b) \curl -sSL https://get.rvm.io | bash -s stable
    c) \curl -sSL https://get.rvm.io | bash -s stable --rails
2. RVM installed.
3. Use 'rvm list' to list all the versions of ruby in your system.
4. Use 'rvm use <version-name>' to switch the version of ruby.
5. Use 'rvm install' to install the versions of ruby.

** Installation of Ruby in Ubuntu **

1. Open the terminal and use the following command :
    sudo apt install ruby-full  
2. If the terminal asks for the password, type it and press enter.
3. If asks for additional disk space [yes/no] press y and hit enter.
4. After installation, check ruby version through ruby -v.
5. Installation is completed.

** Creation of file and run ruby file **

1. Create a ruby file with .rb extension. 
2. Run the file through this command :
    ruby <file-name>.rb

** RUBY Operators **

Ruby has a built-in modern set of operators. Operators are a symbol which is used to perform different operations. For example, +, -, /, *, etc.

    Types of operators :
    a) Unary operator : Unary operators expect a single operand to run on.
    Example : !-> Boolean Not , ~ -> Bitwise Complement , + -> Unary Plus.

    b) Arithmetic operator : Arithmetic operators take numerical values as operands and return them in a single value.
    Example : +,-,/,*,** ,%
        b.1) Addition : Adds values on either side of the operator.
        Example : 
            3.2.2 :010 > a=10
            => 10 
            3.2.2 :011 > b=20
            => 20 
            3.2.2 :012 > a+b
            => 30 
        b.2) Substraction : Subtracts right hand operand from left hand operand.
        Example :
            3.2.2 :013 > a=20
            => 20 
            3.2.2 :014 > b=10
            => 10 
            3.2.2 :015 > a-b
            => 10 
        b.3) Multiplication : Multiplies values on either side of the operator.
        Example :
            3.2.2 :017 > a=20
            => 20 
            3.2.2 :018 > b=30
            => 30 
            3.2.2 :019 > puts a*b
            => 600
        b.4) Division : Divides left hand operand by right hand operand.
        Example :
            3.2.2 :020 > a=20
            => 20 
            3.2.2 :021 > b=10
            => 10 
            3.2.2 :022 > a/b
            => 2 
        b.5) Modulus : Divides left hand operand by right hand operand and returns remainder.
        Example :
            3.2.2 :023 > a=5
            => 5 
            3.2.2 :024 > b=4
            => 4 
            3.2.2 :025 > a%b
            => 1 
        b.6) Exponent : Performs exponential (power) calculation on operators.
        Example : 
            3.2.2 :026 > a=2
            => 2 
            3.2.2 :027 > b=5
            => 5 
            3.2.2 :028 > a**b
            => 32 

    c) Bitwise operator : Bitwise operators work on bits operands.
    Example : & , | , << ,>> ,^, ~

        c.1) & operator : Binary AND Operator copies a bit to the result if it exists in both operands.
        Example : 
            3.2.2 :029 > a=10
            => 10 
            3.2.2 :030 > b=15
            => 15 
            3.2.2 :031 > a&b
            => 10 
        c.2) | operator : Binary OR Operator copies a bit if it exists in either operand.
        Example : 
            3.2.2 :032 > a|b
            => 15 
        c.3) ^ operator: Binary XOR Operator copies the bit if it is set in one operand but not both.
        Example :
            3.2.2 :033 > a^b
            => 5 
        c.4) ~ operator : 	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.
        Example :
            3.2.2 :035 > ~a
             => -11 
        c.5) << operator : Binary Left Shift Operator. The left operands value is moved left by  the number of bits specified by the right operand.
        Example :
            3.2.2 :036 > a<<2
            => 40 
        c.6) >> operator : Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.
        Example :
            3.2.2 :037 > a>>2
             => 2 

    d) Logical operator : Logical operators work on bits operands.
    Example : &&, || 
        d.1) && / AND operator : Called Logical AND operator. If both the operands are true, then the condition becomes true.
        Example :
            3.2.2 :044 > a=30
            => 30 
            3.2.2 :045 > b=40
            => 40 
            3.2.2 :046 > a==30 && b==40
            => true 
        d.2) || / OR operator : Called Logical OR Operator. If any of the two operands are non zero, then the condition becomes true.
        Example :
            3.2.2 :047 > a==30 || b==50
            => true 
        d.3) ! / not operator : Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false.
        Example :
            3.2.2 :048 > !a==30
            => false
        
    e) Ternary operator : Ternary operators first check whether given conditions are true or false, then execute the condition.
    Example : ?: (Conditional Expression)
        3.2.2 :049 > a=20
        => 20 
        3.2.2 :050 > b=40
        => 40 
        3.2.2 :051 > a==20?'Value of a is 20':'Value of a is not 20'
        => "Value of a is 20" 

    f) Assignment operator : Assignment operator assign a value to the operands.
    Example : =, +=, -= , *= , /= , %= , **=

    g) Comparison operator : Comparison operators compare two operands.
    Example : == , ===, != ,> ,<, >=, <= , <=> , .eql? , equal? 

    <=> : Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second and -1 if first operand is less than the second.

    .eql? : True if the receiver and argument have both the same type and equal values.
    1 == 1.0 returns true, but 1.eql?(1.0) is false.

    equal? : True if the receiver and argument have the same object id.
    if aObj is duplicate of bObj then aObj == bObj is true, a.equal?bObj is false but a.equal?aObj is true.

        g.1) == operator : Checks if the value of two operands are equal or not, if yes then condition becomes true.
        Example :
            3.2.2 :052 > a=50
            => 50 
            3.2.2 :053 > b=100
            => 100 
            3.2.2 :054 > a==b
            => false  
        g.2) != operator : Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.
        Example :
            3.2.2 :061 > a!=b
             => true 
        g.3) > operator : Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.
        Example :
            3.2.2 :062 > a>b
            => false 
        g.4) < operator : Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.
        Example :
            3.2.2 :063 > a<b
            => true 
        g.5) >= operator : Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.
        Example :
            3.2.2 :064 > a>=b
             => false 
        g.6) <= operator : Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.
        Example :
            3.2.2 :065 > a<=b
            => true 
        g.7) <=> operator : Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second and -1 if first operand is less than the second.
        Example : 
            3.2.2 :066 > a<=>b
            => -1 
        g.8) === operator : Used to test equality within a when clause of a case statement.
        Example : 
            3.2.2 :067 > a===b
            => false 
        g.9) .eql? operator : True if the receiver and argument have both the same type and equal values.
        Example :
            3.2.2 :068 > a.eql?b
            => false 
        g.10) equal? : True if the receiver and argument have the same object id.
        Example :
            3.2.2 :069 > a.equal?b
             => false 

    h) Range operator : Comparison operators compare two operands.
    Example : .. -> Range is inclusive of the last term
              ... -> Range is exclusive of the last term

** RUBY Variables **

Ruby variables are locations which hold data to be used in the programs. 
    
    There are four types of variables in Ruby:
    a) Local variables : A local variable name starts with a lowercase letter or underscore (_). It is only accessible or have its scope within the block of its initialization. Once the code block completes, variable has no scope.

    b) Class variables : A class variable name starts with @@ sign. They need to be initialized before use. A class variable belongs to the whole class and can be accessible from anywhere inside the class. If the value will be changed at one instance, it will be changed at every instance.

    c) Instance variables : An instance variable name starts with a @ sign. It belongs to one instance of the class and can be accessed from any instance of the class within a method. They only have limited access to a particular instance of a class.
    They don't need to be initialize. An uninitialized instance variable will have a nil value.
    
    d) Global variables : A global variable name starts with a $ sign. Its scope is globally, means it can be accessed from any where in a program.
    An uninitialized global variable will have a nil value.

** Ruby Data Types **

Data types represents a type of data such as text, string, numbers, etc. There are different data types in Ruby:

    a) Numbers
    b) Strings
    c) Symbols
    d) Hashes
    e) Arrays
    f) Booleans

** Ruby Control Statements **

1. If-Else Statements : The Ruby if else statement is used to test condition. There are various types of if statement in Ruby.

    a) if statement : 
        Syntax: if <condition>
                    --code--
                end
        Example :
            3.0.0 :020 > if b>a
            3.0.0 :021 >   puts "Value of b is greater"
            3.0.0 :022 > end
            Value of b is greater
            => nil 

    b) if-else statement : 
        Syntax : if(condition)  
                //code if condition is true  
                else  
                //code if condition is false  
                end  
        Example :
            3.0.0 :013 > a=10
            => 10 
            3.0.0 :014 > b=20
            => 20 
            3.0.0 :015 > if a>b
            3.0.0 :016 >   puts "a is greater than b"
            3.0.0 :017 > else
            3.0.0 :018 >   puts "b is greater than a"
            3.0.0 :019 > end
            b is greater than a
            => nil 

    c) if-else-if (elsif) statement :
        Syntax : if(condition1)  
                //code to be executed if condition1is true  
                elsif (condition2)  
                //code to be executed if condition2 is true  
                else (condition3)  
                //code to be executed if condition3 is true  
                end  
        Example :
            3.0.0 :004 > if a==b
            3.0.0 :005 >   puts "Value of a and b are equal"
            3.0.0 :006 > elsif a>b
            3.0.0 :007 >   puts "Value of a is greater than b"
            3.0.0 :008 > else
            3.0.0 :009 >   puts "Value of b is greater than a"
            3.0.0 :010 > end
            Value of a is greater than b
            => nil 
    
    d) ternay (shortened if statement) statement :
        Syntax : test-expression ? if-true-expression : if-false-expression  
        Example :
            3.0.0 :011 > a>b ? "a is greater than b" : "a is smaller than b"
             => "a is greater than b" 
    
2. Case Statements : The case statement matches one statement with multiple conditions just like a switch statement in other languages.
    Syntax : case <expression>
            when <expression1>
                code...
            ....
            else
                code...
            end
    Example :
        3.0.0 :013 > case num
        3.0.0 :014 > when 1
        3.0.0 :015 >   puts "Number is #{num}"
        3.0.0 :016 > when 2
        3.0.0 :017 >   puts "Number is #{num}"
        3.0.0 :018 > when 3
        3.0.0 :019 >   puts "Number is #{num}"
        3.0.0 :020 > else
        3.0.0 :021 >   puts "Unknown number"
        3.0.0 :022 > end
        Number is 3
        => nil 

3. For Loop : Ruby for loop iterates over a specific range of numbers. Hence, for loop is used if a program has fixed number of iterations.

    Syntax : for <variable> in <expression> do
                code
             end
    Example :
        3.0.0 :023 > for i in 0..5 do
        3.0.0 :024 >     puts i
        3.0.0 :025 > end
        0
        1
        2
        3
        4
        5
        => 0..5 

4. While loop :  While loop is used to iterate a program several times. If the number of iterations is not fixed for a program, while loop is used.
    Syntax : while <condition>
                code
             end
    Example :
        3.0.0 :026 > i=5
        => 5 
        3.0.0 :027 > while i>=0
        3.0.0 :028 >   puts i
        3.0.0 :029 >   i-=1
        3.0.0 :030 > end
        5
        4
        3
        2
        1
        0
        => nil 

5. Do-while loop : Do while loop iterates a part of program several times. It is quite similar to a while loop with the only difference that loop will execute at least once.
    Syntax : loop do 
                --code--
             if <expression>
                break
             end 
    Example :
        3.0.0 :031 > num=4
        => 4 
        3.0.0 :032 > loop do
        3.0.0 :033 >   puts num
        3.0.0 :034 >   num+=1
        3.0.0 :035 >   if num==6
        3.0.0 :036 >     break
        3.0.0 :037 >   end
        3.0.0 :038 > end
        4
        5
        => nil 
            
6. Until Loop : The Ruby until loop runs until the given condition evaluates to true. It exits the loop when condition becomes true. It is just opposite of the while loop which runs until the given condition evaluates to false.           
    Syntax : until <condition>
             --code--
             end
    Example :
        3.0.0 :044 > until num==10
        3.0.0 :045?>   puts num
        3.0.0 :046?>   num+=1
        3.0.0 :047 > end
        6
        7
        8
        9
        => nil 

7. Break statement : The Ruby break statement is used to terminate a loop.
    Example :
        3.0.0 :031 > num=4
        => 4 
        3.0.0 :032 > loop do
        3.0.0 :033 >   puts num
        3.0.0 :034 >   num+=1
        3.0.0 :035 >   if num==6
        3.0.0 :036 >     break
        3.0.0 :037 >   end
        3.0.0 :038 > end
        4
        5
        => nil 

8. Next Statement : The Ruby next statement is used to skip loop's next iteration. 
    Example :
        3.0.0 :048 > for i in 0..5 do
        3.0.0 :049 >     if i==3
        3.0.0 :050 >       next
        3.0.0 :051 >     end
        3.0.0 :052 >     puts i
        3.0.0 :053 > end
        0
        1
        2
        4
        5
        => 0..5 

9. Comments : Ruby comments are non executable lines in a program. 
    a) Single line comment : It is defined by '#' character.
    b) Multi-Line comment : It is used to comments multiple lines at once.
        Syntax :
        =begin
            --code--
        =end

10. Redo Statement : It is used to repeat the current iteration of the loop. The redo statement is executed without evaluating the loop's condition.
The redo statement is used inside a loop.
    Example :
        3.0.0 :085 > for i in 0...5 do
        3.0.0 :086 >     if i==4
        3.0.0 :087 >       i+=1
        3.0.0 :088 >       redo
        3.0.0 :089 >     end
        3.0.0 :090 >     puts i
        3.0.0 :091 > end
        0
        1
        2
        3
        5
        => 0...5 

11. Retry Statement : Ruby retry statement is used to repeat the whole loop iteration from the start. The retry statement is used inside a loop.

** Ruby Core **

1. Ruby Objects : Objects in Ruby are created by calling new method of the class. It is a unique type of method and predefined in the Ruby library.
Ruby objects are instances of the class.
    Syntax : <object-name>=<class-name>.new
    Example :
        3.0.0 :005 > class Shape
        3.0.0 :006 >   def fun
        3.0.0 :007 >     puts "This is function of shape class"
        3.0.0 :008 >   end
        3.0.0 :009 > end
        => :fun 
        3.0.0 :010 > shape=Shape.new
        => #<Shape:0x00005574efdf1560> 
        3.0.0 :011 > puts shape.fun
        This is function of shape class

        => nil 

2. Ruby Classes : Each Ruby class is an instance of class Class. Classes in Ruby are first-class objects.
    Syntax : class <class-name>
                --code--
             end
    Example :
        3.0.0 :005 > class Shape
        3.0.0 :006 >   def fun
        3.0.0 :007 >     puts "This is function of shape class"
        3.0.0 :008 >   end
        3.0.0 :009 > end
        => :fun 
        3.0.0 :010 > shape=Shape.new
        => #<Shape:0x00005574efdf1560> 
        3.0.0 :011 > puts shape.fun
        This is function of shape class

        => nil 

3. Methods : It prevent us from writing the same code in a program again and again. It is a set of expression that returns a value.
    Syntax : def <method-name>
                --code--
             end
    Example :
        3.0.0 :001 > def add_numbers
        3.0.0 :002 >   return 2
        3.0.0 :003 > end
        => :add_numbers 
        3.0.0 :004 > puts add_numbers
        2
        => nil 

    Methods Withs parameter :
    Syntax : def <method-name>(parameters)
                --code--
             end
    Example :
        3.0.0 :001 > def two_numbers(a,b)
        3.0.0 :002 >   return a+b
        3.0.0 :003 > end
        => :two_numbers 
        3.0.0 :004 > puts two_numbers(3,4)
        7
        => nil 

4. Blocks : Ruby code blocks are called closures in other programming languages. It consist of a group of codes which is always enclosed with braces or written between do..end. 
    A block is written in two ways,

    a) Multi-line between do and end (multi-line blocks are niot inline) : 
        Example : [10,20,30].each do |n|
                    puts n
                  end
    b) Inline between braces {} : 
        Example : [10, 20, 30].each {|n| puts n}  
    
    c) The yield statement is used to call a block within a method with a value.
        Syntax : def <method-name>
                    --code--
                    yield
                 end
                <method-name> {-- code --}
    
    d) Passing parameters with yield.
        Syntax : def <method-name>
                    yield <parameter>
                    --code--
                 end
                <method-name> {|i| --code--}
    
    e) BEGIN and END block : It is used to declare that file is being loaded and file has been loaded respectively.
        Syntax : BEGIN{
            --code--
        }
        END{
            --code--
        }
        --code--
    
    f) Ampersand block : The &block is a way to pass a reference (instead of a local variable) to the block to a method.
        Syntax : def <method-name>(&b)
                    --code--
                    b.call
                 end
                <method-name> {--code--}

5. Modules : Ruby module is a collection of methods and constants. A module method may be instance method or module method. Module name should start with a capital letter.
    Syntax :
    module <Module-name>
        --code--
    end

    Modules basically serve two purposes:

    a) They act as namespace. They prevent the name clashes.
    b) They allow the mixin facility to share functionality between classes.

    Mixins : Ruby doesn't support multiple inheritance. Modules eliminate the need of multiple inheritance using mixin in Ruby.When you include a module within a class, the class will have access to the methods of the module.

6. Strings : Ruby string object holds and manipulates an arbitary sequence of bytes, typically representing characters. They are created using String::new or as literals.

    a) Quotes : Ruby string literals are enclosed within single and double quotes.
        Example : puts "some message"
    b) Accessing string elements : With the help of [] brackets. -1 index is for last character.
    c) Multiline string : Strings can be written in multiple lines.
        c.1) String can be written within double quotes.
        c.2) The % character is used and string is enclosed within / character.
        c.3) In heredoc syntax, we use << and string is enclosed within word STRING.
    d) Variable Interpolation : It is replacing variables with values inside string literals.
        Example : str="John"
                  puts "Hello ,#{str}"
    e) Concatenate Strings : To join more than one strings.
        There are four ways to concatenate Ruby strings into single string:
        e.1) Using plus sign in between strings.
        e.2) Using a single space in between strings.
        e.3) Using << sign in between strings.
        e.4) Using concat method in between strings.
    f) Freezing : In Ruby, by default strings are not immutable. To make them immutable, freeze method can be used. Immutable is defined as an existing string can't be modified, only a new string can be created out of them.
        Syntax : string-name.freeze
    g) Comparing Strings : Strings can be compared with three operators.
        g.1) With == operator : Returns true or false
        g.2) With eql? Operator : Returns true or false
        g.3) With casecmp method : Returns 0 if matched or 1 if not matched
    
    Methods of String Class :

    6.1) ::new : Returns a new String that is a copy of string.
    Example :
        3.0.0 :002 > str=String.new
        => "" 
        3.0.0 :003 > str
        => "" 
        3.0.0 :004 > str="This is new method"
        => "This is new method" 
    With initialization:
        3.0.0 :005 > str=String.new('Foo')
        => "Foo" 
        3.0.0 :006 > str
        => "Foo" 
    
    6.2) ::try_convert : Try to convert obj into a String, using to_str method. Returns converted string or nil if obj cannot be converted for any reason.
    Example :
        3.0.0 :012 > String.try_convert(str)
        => "Foo" 
    
    6.3) * : Returns a new String containing integer copies of self.
    Example :
        3.0.0 :022"> str="hello "
        => "hello " 
        3.0.0 :023 > str * 3
        => "hello hello hello " 
    
    6.4) % : Returns the result of formatting object into the format specification
    Example :
        3.0.0 :036 > a=123
        => 123 
        3.0.0 :037 > "%04d" % a
        => "0123" 
    
    6.5) + : string + other_string → new_string
    Example :
        3.0.0 :040 > a
        => "0123" 
        3.0.0 :041 > a + "hello"
        => "0123hello" 

    6.6) << : Concatenate two or more strings.
    Example :
        3.0.0 :056 > a << "John"
        => "HiiJohn" 
    6.7) <=> : Compare two strings.
    1 if other_string is larger.
    0 if the two are equal.
    1 if other_string is smaller.
    nil if the two are incomparable.
    Example :
        3.0.0 :061 > a<=>'hello'
        => -1 

    6.8) == : Returns true if object has the same length and content, false otherwise.
    Example :
        3.0.0 :063 > a
        => "Hello" 
        3.0.0 :064 > a=="Hello"
        => true 
        3.0.0 :065 > a=="hello"
        => false 

    6.9) === : Returns true if object has the same length and content, false otherwise.
    Example :   
        3.0.0 :072 > a=1
        => 1 
        3.0.0 :073 > a==="1"
        => false 

    6.10) string =~ regexp : Returns the Integer index of the first substring that matches the given regexp, or nil if no match found:
    Example :
        3.0.0 :074 > a="Hello"
        => "Hello" 
        3.0.0 :075 > a =~ /l/
        => 2 
        3.0.0 :076 > a =~ /a/
        => nil 

    6.11) [] : Returns the substring of given string specified by arguments.
        string[index] → new_string or nil
        string[start, length] → new_string or nil
        string[range] → new_string or nil
        string[regexp, capture = 0] → new_string or nil
        string[substring] → new_string or nil

        Example :
            3.0.0 :079 > str="hello"
            => "hello" 
            3.0.0 :082 > str[0]
            => "h" 
            3.0.0 :083 > str[0,2]
            => "he" 
            3.0.0 :084 > str[1..3]
            => "ell" 
        
    6.12) ascii_only? : Returns true if string contains ASCII characters only false otherwise.
    Example :
        3.0.0 :088 > str
        => "hho" 
        3.0.0 :089 > str.ascii_only?
        => true 
    
    6.13) b : Returns a copy of self that has ASCII-8BIT encoding; the underlying bytes are not modified:
    Example :
        3.0.0 :090"> str="Hello"
        => "Hello" 
        3.0.0 :091 > t=str.b
        => "Hello" 
        3.0.0 :092 > t
        => "Hello"
    
    6.14) byteindex : Returns the Integer byte-based index of the first occurrence of the given substring, or nil if none found.
    Example :
        3.2.2 :001 > str="Hello"
        => "Hello" 
        3.2.2 :002 > str.byteindex('e')
        => 1 
    With offset; example :
        3.2.2 :003 > str.byteindex('l',3)
        => 3 
    
    6.15) byterindex : Returns the Integer byte-based index of the last occurrence of the given substring, or nil if none found:
    Example :
        3.2.2 :006 > str = "Hello"
        => "Hello" 
        3.2.2 :007 > str.byterindex('l')
        => 3 
    With offset example :
        3.2.2 :010 > str.byterindex('l',2)
         => 2 
        
    6.16) bytes : Returns an array of the bytes in self.
    Example :
        3.2.2 :017 > str.bytes
         => [72, 101, 108, 108, 111]  
    6.17) bytesize : Returns the count of bytes (not characters) in self.
    Example :
        3.2.2 :018 > str.bytesize
        => 5 
    6.18) byteslice (index,length=1) : Returns the substring.
    Example :
        3.2.2 :006 > str = "Hello"
        => "Hello" 
        3.2.2 :019 > str.byteslice(2)
        => "l" 
        3.2.2 :020 > str.byteslice(2,3)
        => "llo" 

    6.19) bytesplice(index, length, str) → string
          bytesplice(range, str) → string
        Replaces some of the content and gives a new string.
    Example :
        3.2.2 :024 > str="Hello"
        => "Hello" 
        3.2.2 :025 > str.bytesplice(1,4,"ii")
        => "Hii" 

    6.20) Capitalize : Returns a string containing the characters in self; the first character is upcased; the remaining characters are downcased.
    Example :
        3.2.2 :030 > str="hELLO"
        => "hELLO" 
        3.2.2 :031 > str.capitalize
        => "Hello"  
    
    6.21) Capitalize! : Upcases the first character in self; downcases the remaining characters; returns self if any changes were made, nil otherwise.
    Example :
        3.2.2 :032 > str
        => "hELLO" 
        3.2.2 :033 > str.capitalize!
        => "Hello" 
    
    6.22) casecmp : Compares self.downcase and other_string.downcase
        -1 if other_string.downcase is larger.
        0 if the two are equal.
        1 if other_string.downcase is smaller.
        nil if the two are incomparable.
    Example : 
        3.0.0 :001 > str="Hello"
        => "Hello" 
        3.0.0 :002 > str.casecmp("hello")
        => 0 
    
    6.23) casecmp? : Returns true if self and other_string are equal after Unicode case folding, otherwise false
    Example :
        3.0.0 :003 > str.casecmp?("hello")
        => true 

    6.24) center(size, pad_string = ' ') : Returns a centered copy of self.
    Example :
        3.0.0 :004 > str
        => "Hello" 
        3.0.0 :005 > str.center(10,'*')
        => "**Hello***" 

    6.25) chars : Returns an array of the characters in self.
    Example :
        3.0.0 :006 > str.chars
        => ["H", "e", "l", "l", "o"] 

    6.26) chomp : Returns a new string copied from self, with trailing characters possibly removed. When line_sep is "\n", removes the last one or two characters if they are "\r", "\n", or "\r\n" (but not "\n\r"):
    Example :
        3.0.0 :010 > str="hello\n\n"
        => "hello\n\n" 
        3.0.0 :011 > str.chomp
        => "hello\n" 
    Another Example :
        3.0.0 :013 > str="hello"
        => "hello" 
        3.0.0 :014 > str.chomp('o')
        => "hell" 

    6.27) chomp!(line_sep = $/) : Like String#chomp, but modifies self in place; returns nil if no modification made, self otherwise.
    Example :
        3.0.0 :015 > str
        => "hello" 
        3.0.0 :016 > str.chomp!('o')
        => "hell" 
        3.0.0 :017 > str
        => "hell" 

    6.28) chop : Returns a new string copied from self, with trailing characters possibly removed.Removes "\r\n" if those are the last two characters.
    Example :
        3.0.0 :018 > str="hello\r\n"
        => "hello\r\n" 
        3.0.0 :019 > str.chop
        => "hello" 
    Otherwise removes the last character if it exists.
        3.0.0 :022 > str
        => "hello" 
        3.0.0 :023 > str.chop
        => "hell" 
    
    6.29) chop! : It modifies self in place; returns nil if self is empty, self otherwise.
    Example :
        3.0.0 :024 > str
        => "hello" 
        3.0.0 :025 > str.chop!
        => "hell" 

    6.30) chr : Returns a string containing the first character of self
    Example :
        3.0.0 :026 > str.chr
         => "h" 

    6.31) clear : Removes the contents of self.
    Example : 
        3.0.0 :027 > str.clear
        => "" 

    6.32) codepoints : Returns an array of the codepoints in self; each codepoint is the integer value for a character.
    Example :
        3.0.0 :029 > str="hello"
        => "hello" 
        3.0.0 :030 > str.codepoints
        => [104, 101, 108, 108, 111] 

    6.33) concat : Concatenates each object in objects to self and returns self.
    Example :
        3.0.0 :031 > str.concat(' Welcome',' here');
        => "hello Welcome here" 

    6.34) count(*selectors) : Returns the total number of characters in self that are specified by the given selectors
    Example :
        3.0.0 :033 > str="hello"
        => "hello" 
        3.0.0 :034 > str.count('lo')
        => 3  

    6.35) delete(*selectors) : Returns a copy of self with characters specified by selectors removed.
    Example :
        3.0.0 :042 > str
        => "hello" 
        3.0.0 :043 > str.delete('lo')
        => "he" 

    6.36) delete!(*selectors) : It modifies self in place. Returns self if any changes were made, nil otherwise.
    Example :
        3.0.0 :044 > str.delete!('lo')
        => "he" 
    
    6.37) delete_prefix (prefix) : Returns a copy of self with leading substring prefix removed
    Example :
        3.0.0 :048 > str.delete_prefix('he')
        => "llo" 

    6.38) delete_prefix!(prefix) : Returns self if the prefix is removed, nil otherwise.

    6.39) delete_suffix (suffix) : Returns a copy of self with trailing substring suffix removed
    Example :
        3.0.0 :049 > str
        => "hello" 
        3.0.0 :050 > str.delete_suffix('llo')
        => "he" 
    
    6.40) delete_suffix!(suffix) : Returns self if the suffix is removed, nil otherwise.
    Example :
        3.0.0 :051 > str.delete_suffix!('llo')
        => "he" 

    6.41) downcase(*options) : Returns a string containing the downcased characters in self.
    Example :
        3.0.0 :053 > str="HeLLo"
        => "HeLLo" 
        3.0.0 :054 > str.downcase
        => "hello" 

    6.42) downcase! : Modify original string.
    Example :
        3.0.0 :055 > str
        => "HeLLo" 
        3.0.0 :056 > str.downcase!
        => "hello" 

    6.43) dump : Returns a printable version of self, enclosed in double-quotes, with special characters escaped, and with non-printing characters replaced by hexadecimal notation.
    Example :
        3.0.0 :057 > str="hello\n "
        => "hello\n " 
        3.0.0 :058 > str.dump
        => "\"hello\\n \"" 

    6.44) each_byte {|byte| ...} : Calls the given block with each successive byte from self; returns self.
    Example :
        3.0.0 :061 > str.each_byte {|byte| print byte , ' '}
        104 101 108 108 111  => "hello" 

    6.45) each_char : Calls the given block with each successive character from self; returns self.
    Example :
        3.0.0 :062 > str.each_char {|c| print c,' '}
        h e l l o  => "hello" 

    6.46) each_codepoint : Calls the given block with each successive codepoint from self; each codepoint is the integer value for a character; returns self.
    Example :
        3.0.0 :063 > str.each_codepoint{|c| print c,' '}
        104 101 108 108 111  => "hello" 

    6.47) empty? : Returns true if the length of self is zero, false otherwise.
    Example : 
        3.0.0 :065 > str.empty?
        => false

    6.48) encoding : Returns the Encoding object that represents the encoding of obj.
    Example :
        3.0.0 :070 > str.encoding
         => #<Encoding:UTF-8> 
        
    6.49) end_with?(*strings) : Returns whether self ends with any of the given strings
    Example :
        3.0.0 :072 > str.end_with?('ello')
         => false 

    6.50) eql? : Returns true if object has the same length and content; as self; false otherwise.
    Example :
        3.0.0 :073 > str="hello"
        => "hello" 
        3.0.0 :074 > str.eql?("Hello")
        => false 
    
    6.51) force_encoding (encoding) : Changes the encoding of self to encoding, which may be a string encoding name or an Encoding object; returns self.
    Example : 
        3.0.0 :075 > str.force_encoding('ascii')
        => "hello" 
        3.0.0 :076 > str.encoding
        => #<Encoding:US-ASCII> 

    6.52) freeze : To make the string immutable.
    Example :
        3.0.0 :080 > str.freeze
        => "hello" 
        3.0.0 :081 > str[0]='l'
        Traceback (most recent call last):
                5: from /home/beryl/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `<main>'
                4: from /home/beryl/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `load'
                3: from /home/beryl/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/irb-1.3.0/exe/irb:11:in `<top (required)>'
                1: from (irb):81:in `[]='

    6.53) getbyte(index) : Returns the byte at zero-based index as an integer, or nil if index is out of range
    Example :
        3.0.0 :003 > str="Hello"
        => "Hello" 
        3.0.0 :004 > str.getbyte(1)
        => 101 
    
    6.54) hash : Returns the integer hash value for self. The value is based on the length, content and encoding of self
    Example :
        3.0.0 :006 > str.hash
        => -902046462397498627 
    
    6.55) hex : Interprets the leading substring of self as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number; returns zero if there is no such leading substring
    Example :
        3.0.0 :007 > str.hex
         => 0 

    6.56) include? : Returns true if self contains other_string, false otherwise.
    Example :
        3.0.0 :008 > str.include?('o')
        => true 

    6.57) index (substring, offset = 0) : Returns the integer index of the first match for the given argument, or nil if none found; the search of self is forward, and begins at position offset (in characters).
    Example :
        3.0.0 :001 > str="hello"
        => "hello" 
        3.0.0 :002 > str.index('l')
        => 2 
    
    6.58) initialize_copy(other_string) : Replaces the contents of self with the contents of other_string
    Example :
        3.0.0 :004 > str.replace('Hii')
        => "Hii" 
    
    6.59) insert (index,other_string) : Inserts the given other_string into self; returns self.
    Example :
        3.0.0 :005 > str
        => "Hii" 
        3.0.0 :006 > str.insert(2," Hello")
        => "Hi Helloi" 

    6.60) inspect : Returns a printable version of self, enclosed in double-quotes, and with special characters escaped.
    Example :
        3.0.0 :007 > str.inspect
        => "\"Hi Helloi\"" 

    6.61) intern : Returns the Symbol corresponding to str, creating the symbol if it did not previously exist.
    Example :
        3.0.0 :008 > str.intern
        => :"Hi Helloi" 
        3.0.0 :009 > "Welcome".intern   # Welcome symbol not exist previously
        => :Welcome 

    6.62) length : Returns the count of characters (not bytes) in self.
    Example :
        3.0.0 :010 > str.length
        => 9 

    6.63) ljust(size,pad_string=' ') : Returns a left-justified copy of self.
    Example : 
        3.0.0 :012 > str="hello"
        => "hello" 
        3.0.0 :013 > str.ljust(10)
        => "hello     " 

    6.64) lstrip : Returns a copy of self with leading whitespace removed.
    Example :
        3.0.0 :015 > str="\n\r\nhello"
        => "\n\r\nhello" 
        3.0.0 :016 > str.lstrip
        => "hello"

    6.65) lstrip! : Any modifications are made in self; returns self if any modification are made, nil otherwise.
    Example :
        3.0.0 :017 > str.lstrip!
        => "hello"
    
    6.66) next : Returns the successor to self. The successor is calculated by incrementing characters.
    Example :
        3.0.0 :019 > str
        => "hello" 
        3.0.0 :020 > str.succ
        => "hellp" 

    6.67) next! : It modifies self in place; returns self.
    Example :
        3.0.0 :021 > str.succ!
        => "hellp" 
        3.0.0 :022 > str
        => "hellp" 

    6.68) oct : Interprets the leading substring of self as a string of octal digits (with an optional sign) and returns the corresponding number; returns zero if there is no such leading substring.
    Example : 
        3.0.0 :024 > '123'.oct
        => 83 

    6.69) ord : Returns the integer ordinal of the first character of self.
    Example :
        3.0.0 :025 > str.ord
        => 104 
    
    6.70) partition(string_or_regexp) → [head, match, tail] 
    Example: 
        3.0.0 :026 > str.partition('l')
        => ["he", "l", "lp"]
    
    6.71) prepend (*other_string) : Prepends each string in other_strings to self and returns self.
    Example :
        3.0.0 :028 > str="hello"
        => "hello" 
        3.0.0 :029 > str.prepend("Welcome ","John ")
        => "Welcome John hello" 

    6.72) replace(other_string) : Replaces the contents of self with the contents of other_string.
    Example :
        3.0.0 :030 > str
        => "Welcome John hello" 
        3.0.0 :031 > str.replace("hello")
        => "hello" 
    
    6.73) reverse : Returns a new string with the characters from self in reverse order.
    Example :
        3.0.0 :032 > str
        => "hello" 
        3.0.0 :033 > str.reverse
        => "olleh" 

    6.74) reverse! : Returns self with its characters reversed.
    Example :
        3.0.0 :034 > str
        => "hello" 
        3.0.0 :035 > str.reverse!
        => "olleh" 

    6.75) rjust (size,pad_string=' ') : Returns a right-justified copy of self.
    Example :
        3.0.0 :036 > str
        => "olleh" 
        3.0.0 :037 > str.rjust(10)
        => "     olleh" 
    
    6.76) rpartition(sep) → [head, match, tail] 
    Example :
        3.0.0 :039 > str="hello"
        => "hello" 
        3.0.0 :040 > str.rpartition('l')
        => ["hel", "l", "o"] 

    6.77) rstrip : Returns a copy of the receiver with trailing whitespace removed.
    Example :
        3.0.0 :043 > str="hello\n\v\r"
        => "hello\n\v\r" 
        3.0.0 :044 > str.rstrip
        => "hello" 
    
    6.78) rstrip! : Returs self and same functionality as rstrip.

7. Arrays : Ruby arrays are ordered collections of objects. They can hold objects like integer, number, hash, string, symbol or any other array.
    
    a) Creation of array : 
        a.1) Using literal constructor []
        a.2) Using new class method.
        Syntax : arr=Array.new
                or arr= Array.new(size) 
    b) length : To find the length of array.
        Syntax : <arr-name>.length
    c) Accessing array elements : using [] method
        Syntax : array-name[index];
    d) at method : To access a particular element, at method can also be used.
        Syntax : <arr-name>.at(index)
    e) fetch method : The fetch method is used to provide a default value error for out of array range indices.
        Syntax : <arr-name>.fetch(numbers,"default value")
    f) first and last method : The first and last method will return first and last element of an array respectively.
    g) take method : The take method returns the first n elements of an array.
    h) drop method : The drop method is the opposite of take method. It returns elements after n elements have been dropped.
    i) Adding items in array : 
        i.1) push or <<  -> at the end of an array
        i.2) unshift  -> front of array
        i.3) insert -> at particular index 
            Syntax : <arr-name>.insert(index,value)
    j) Remove items from array : To remove elements from an array.
        j.1) pop -> from end of an array
        j.2) shift   -> From start of an array
        j.3) delete  -> Delete from anywhere in an array.
            Syntax : <arr-name>.delete(value)
        j.4) uniq -> To remove duplicates from an array.
            Syntax : <arr-name>.uniq

8. Hashes : A hash is a collection of unique keys and their values. If a hash is accessed with a key that does not exist, the method will return nil.
    Syntax : <hash-name>={key1=>value1 , key2=>value2, ...}
                                or
            <hash-name>={key1:value1 , key2:value2 , ...}

9. Date and Time : Ruby has Mainly three classes related to date and time in its documentation.
    a) Date
    b) DateTime
    c) Time

10. Ranges : It represents a set of values with a beginning and an end. The ranges which has .. in them, run from beginning to end inclusively. The ranges which has ... in them, run exclusively the end value.
    Ruby has a variety of ways to define ranges.
    a) Ranges as sequences : The most natural way to define a range is in sequence. They have a start point and an end point. 
    b) Ranges as conditions : Ranges are also defined as conditional expressions. Different conditions are defined in a set of lines. These conditions are enclosed within start statement and end statement.
    c) Ranges as intervals : Intervals are represented by === case equality operator.
    d) Reverse range : Ruby reverse range operator does not return any value. We can use reverse function of ruby to reverse the range.

11. Iterators : Iterator is a concept used in object-oriented language. Iteration means doing one thing many times like a loop.
    a) Each Iterator :The Ruby each iterator returns all the elements from a hash or array.
        Syntax : (collection).each do |variable|
                    --code--
                 end
    b) Times Iterator : A loop is executed specified number of times by the times iterator. Loop will start from zero till one less than specified number.
        Syntax : x.times do |variable|
                    --code--
                 end
    c) Step Iterator : A step iterator is used to iterate while skipping over a range.
        Syntax : (controller).step(<step-count>) do |variable|
                    --code--
                 end
    d) Each line operator : A each_line iterator is used to iterate over a new line in a string.
        Syntax : <string with\n>.each_line do |variable|
                    --code--
                 end
    e) Upto Iterator : An upto iterator iterates from number x to number y.
        Syntax : x.upto(y) do |variable|
                    --code--
                 end
    f) Downto iterator : An downto iterator iterates from number y to number x.
        Syntax : y.downto(x) do |variable|
                    --code--
                 end
    
12. File I/O : Ruby I/O is a way to interact with your system. IO class is the basis for all input and output in Ruby. 
    Common modes in I/O port
    a) "r": read-only mode is the default mode starts at beginning of file.
    b) "r+": read-write mode, starts at beginning of file.
    c) "w": write-only mode, either creates a new file or truncates an existing file for writing.
    d) "w+": read-write mode, either creates a new file or truncates an existing file for reading and writing.
    e) "a": write-only mode, if file exists it will append the file othrwise a new file will be created for writing only.
    f) "a+": read and write mode, if file exists it will append the file othrwise a new file will be created for writing and reading.

    A) Opening a file : There are two methods to open a file in ruby.
    A.1) File.new method : Using this method a new file can be created for reading, writing or both.
        Syntax : f=File.new("filename.rb")

    A.2) File.open method : Using this method a new file object is created. That file object is assigned to a file.
        Syntax : File.open("filename.rb","mode") do |f|
    
    B) Reading a file : There are three different methods to read a file.
    B.1) To return a single line, following syntax is used.
        Syntax : f.gets
                 --code--
    B.2) To return the whole file after the current position.
        Syntax : f.read
                    --code--
    B.3) To return file as an array of lines
        Syntax : f.readlines  
                    --code--
    B.4) Sysread method : The sysread method is also used to read the content of a file. With the help of this method you can open a file in any mode.  

    C) Renaming and Deleting of a file : Ruby files are renamed using rename method and deleted using delete mehtod.
    C.1) Rename : Syntax : File.rename("olderName.txt", "newName.txt")  
    C.2) Delete : Syntax : File.delete("filename.txt")  

    D) Writing in a file : You can write content into a file. File needs to be opened in write mode for this method.

13. Directories : Class Dir has directory streams as objects which represents directories in underlying file system. Directories are handled with Dir class.
    
    a) Creating a directory : To create a directory mkdir command is used. You can give permission to a directory if you want (optional).
        Syntax: Dir.mkdir "directory-name",permission
    b) Checking directory : To check whether a directory exists or not exist? Method is used.
        Syntax : Dir.exist?"directory-name"
    c) Current working directory : To know the current working directory pwd method is used.
        Syntax : Dir.pwd
    d) Remove directory : To remove a directory, rmdir, unlink or delete methods are used. They perform same function for a Ruby directory.
        Syntax : Dir.rmdir "directory-name"

14. Exceptions : In a Ruby program, when something goes wrong, it throws an exceptional behavior. By default Ruby program terminates on throwing an exception.

15. OOPS Concept : Ruby is a true object oriented language which can be embedded into Hypertext Markup Language. Everything in Ruby is an object. OOPs is a programming concept that uses objects and their interactions to design applications and computer programs. There are four basic concepts in OOPS :

    a) Encapsulation: It hides the implementation details of a class from other objects due to which a class is unavailable to the rest of the code. Its main purpose is to protect data from data manipulation.

    b) Polymorphism: It is the ability to represent an operator or function in different ways for different data input.

    c) Inheritance: It creates new classes from pre defined classes. New class inherit behaviors of its parent class which is referred as superclass. In this way, pre defined classes can be made more reusable and useful.

    d) Abstraction: It hides the complexity of a class by modelling classes appropriate to the problem.

16. Constructor : A constructor is automatically called when an object is created. They do not return any values. In Ruby, they are called initialize.
    Syntax : class <ClassName>
                def initialize
                    --code--
                end
             end   