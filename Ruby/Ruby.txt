Ruby is a dynamic, open source, object oriented and reflective programming language. It is fully object oriented programming language. Everything is an object in Ruby.

** Installation of RVM **
1. Open your linux terminal and use the following commands.
    a) gpg2 --keyserver keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
    b) \curl -sSL https://get.rvm.io | bash -s stable
    c) \curl -sSL https://get.rvm.io | bash -s stable --rails
2. RVM installed.
3. Use 'rvm list' to list all the versions of ruby in your system.
4. Use 'rvm use <version-name>' to switch the version of ruby.
5. Use 'rvm install' to install the versions of ruby.

** Installation of Ruby in Ubuntu **

1. Open the terminal and use the following command :
    sudo apt install ruby-full  
2. If the terminal asks for the password, type it and press enter.
3. If asks for additional disk space [yes/no] press y and hit enter.
4. After installation, check ruby version through ruby -v.
5. Installation is completed.

** Creation of file and run ruby file **

1. Create a ruby file with .rb extension. 
2. Run the file through this command :
    ruby <file-name>.rb

** RUBY Operators **

Ruby has a built-in modern set of operators. Operators are a symbol which is used to perform different operations. For example, +, -, /, *, etc.

    Types of operators :
    a) Unary operator : Unary operators expect a single operand to run on.
    Example : !-> Boolean Not , ~ -> Bitwise Complement , + -> Unary Plus.

    b) Arithmetic operator : Arithmetic operators take numerical values as operands and return them in a single value.
    Example : +,-,/,*,** ,%
    c) Bitwise operator : Bitwise operators work on bits operands.
    Example : & , | , << ,>> ,^, ~
    d) Logical operator : Logical operators work on bits operands.
    Example : &&, || 
    e) Ternary operator : Ternary operators first check whether given conditions are true or false, then execute the condition.
    Example : ?: (Conditional Expression)
    f) Assignment operator : Assignment operator assign a value to the operands.
    Example : =, +=, -= , *= , /= , %= , **=
    g) Comparison operator : Comparison operators compare two operands.
    Example : == , ===, != ,> ,<, >=, <= , <=> , .eql? , equal? 

    <=> : Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second and -1 if first operand is less than the second.

    .eql? : True if the receiver and argument have both the same type and equal values.
    1 == 1.0 returns true, but 1.eql?(1.0) is false.

    equal? : True if the receiver and argument have the same object id.
    if aObj is duplicate of bObj then aObj == bObj is true, a.equal?bObj is false but a.equal?aObj is true.

    h) Range operator : Comparison operators compare two operands.
    Example : .. -> Range is inclusive of the last term
              ... -> Range is exclusive of the last term

** RUBY Variables **

Ruby variables are locations which hold data to be used in the programs. 
    
    There are four types of variables in Ruby:
    a) Local variables : A local variable name starts with a lowercase letter or underscore (_). It is only accessible or have its scope within the block of its initialization. Once the code block completes, variable has no scope.

    b) Class variables : A class variable name starts with @@ sign. They need to be initialized before use. A class variable belongs to the whole class and can be accessible from anywhere inside the class. If the value will be changed at one instance, it will be changed at every instance.

    c) Instance variables : An instance variable name starts with a @ sign. It belongs to one instance of the class and can be accessed from any instance of the class within a method. They only have limited access to a particular instance of a class.
    They don't need to be initialize. An uninitialized instance variable will have a nil value.
    
    d) Global variables : A global variable name starts with a $ sign. Its scope is globally, means it can be accessed from any where in a program.
    An uninitialized global variable will have a nil value.

** Ruby Data Types **

Data types represents a type of data such as text, string, numbers, etc. There are different data types in Ruby:

    a) Numbers
    b) Strings
    c) Symbols
    d) Hashes
    e) Arrays
    f) Booleans

** Ruby Control Statements **

1. If-Else Statements : The Ruby if else statement is used to test condition. There are various types of if statement in Ruby.

    a) if statement : 
        Syntax: if <condition>
                    --code--
                end

    b) if-else statement : 
        Syntax : if(condition)  
                //code if condition is true  
                else  
                //code if condition is false  
                end  

    c) if-else-if (elsif) statement :
        Syntax : if(condition1)  
                //code to be executed if condition1is true  
                elsif (condition2)  
                //code to be executed if condition2 is true  
                else (condition3)  
                //code to be executed if condition3 is true  
                end  
    
    d) ternay (shortened if statement) statement :
        Syntax : test-expression ? if-true-expression : if-false-expression  
    
2. Case Statements : The case statement matches one statement with multiple conditions just like a switch statement in other languages.
    Syntax : case <expression>
            when <expression1>
                code...
            ....
            else
                code...
            end

3. For Loop : Ruby for loop iterates over a specific range of numbers. Hence, for loop is used if a program has fixed number of iterations.

    Syntax : for <variable> in <expression> do
                code
             end

4. While loop :  While loop is used to iterate a program several times. If the number of iterations is not fixed for a program, while loop is used.
    Syntax : while <condition>
                code
             end

5. Do-while loop : Do while loop iterates a part of program several times. It is quite similar to a while loop with the only difference that loop will execute at least once.
    Syntax : loop do 
                --code--
             if <expression>
                break
             end 
            
6. Until Loop : The Ruby until loop runs until the given condition evaluates to true. It exits the loop when condition becomes true. It is just opposite of the while loop which runs until the given condition evaluates to false.           
    Syntax : until <condition>
             --code--
             end
    
7. Break statement : The Ruby break statement is used to terminate a loop.

8. Next Statement : The Ruby next statement is used to skip loop's next iteration. 

9. Comments : Ruby comments are non executable lines in a program. 
    a) Single line comment : It is defined by '#' character.
    b) Multi-Line comment : It is used to comments multiple lines at once.
        Syntax :
        =begin
            --code--
        =end

10. Redo Statement : It is used to repeat the current iteration of the loop. The redo statement is executed without evaluating the loop's condition.
The redo statement is used inside a loop.

11. Retry Statement : Ruby retry statement is used to repeat the whole loop iteration from the start. The retry statement is used inside a loop.

** Ruby Core **

1. Ruby Objects : Objects in Ruby are created by calling new method of the class. It is a unique type of method and predefined in the Ruby library.
Ruby objects are instances of the class.
    Syntax : <object-name>=<class-name>.new

2. Ruby Classes : Each Ruby class is an instance of class Class. Classes in Ruby are first-class objects.
    Syntax : class <class-name>
                --code--
             end

3. Methods : It prevent us from writing the same code in a program again and again. It is a set of expression that returns a value.
    Syntax : def <method-name>
                --code--
             end
    Methods Withs parameter :
    Syntax : def <method-name>(parameters)
                --code--
             end

4. Blocks : Ruby code blocks are called closures in other programming languages. It consist of a group of codes which is always enclosed with braces or written between do..end. 
    A block is written in two ways,

    a) Multi-line between do and end (multi-line blocks are niot inline) : 
        Example : [10,20,30].each do |n|
                    puts n
                  end
    b) Inline between braces {} : 
        Example : [10, 20, 30].each {|n| puts n}  
    
    c) The yield statement is used to call a block within a method with a value.
        Syntax : def <method-name>
                    --code--
                    yield
                 end
                <method-name> {-- code --}
    
    d) Passing parameters with yield.
        Syntax : def <method-name>
                    yield <parameter>
                    --code--
                 end
                <method-name> {|i| --code--}
    
    e) BEGIN and END block : It is used to declare that file is being loaded and file has been loaded respectively.
        Syntax : BEGIN{
            --code--
        }
        END{
            --code--
        }
        --code--
    
    f) Ampersand block : The &block is a way to pass a reference (instead of a local variable) to the block to a method.
        Syntax : def <method-name>(&b)
                    --code--
                    b.call
                 end
                <method-name> {--code--}

5. Modules : Ruby module is a collection of methods and constants. A module method may be instance method or module method. Module name should start with a capital letter.
    Syntax :
    module <Module-name>
        --code--
    end

    Modules basically serve two purposes:

    a) They act as namespace. They prevent the name clashes.
    b) They allow the mixin facility to share functionality between classes.

    Mixins : Ruby doesn't support multiple inheritance. Modules eliminate the need of multiple inheritance using mixin in Ruby.When you include a module within a class, the class will have access to the methods of the module.

6. Strings : Ruby string object holds and manipulates an arbitary sequence of bytes, typically representing characters. They are created using String::new or as literals.

    a) Quotes : Ruby string literals are enclosed within single and double quotes.
        Example : puts "some message"
    b) Accessing string elements : With the help of [] brackets. -1 index is for last character.
    c) Multiline string : Strings can be written in multiple lines.
        c.1) String can be written within double quotes.
        c.2) The % character is used and string is enclosed within / character.
        c.3) In heredoc syntax, we use << and string is enclosed within word STRING.
    d) Variable Interpolation : It is replacing variables with values inside string literals.
        Example : str="John"
                  puts "Hello ,#{str}"
    e) Concatenate Strings : To join more than one strings.
        There are four ways to concatenate Ruby strings into single string:
        e.1) Using plus sign in between strings.
        e.2) Using a single space in between strings.
        e.3) Using << sign in between strings.
        e.4) Using concat method in between strings.
    f) Freezing : In Ruby, by default strings are not immutable. To make them immutable, freeze method can be used. Immutable is defined as an existing string can't be modified, only a new string can be created out of them.
        Syntax : string-name.freeze
    g) Comparing Strings : Strings can be compared with three operators.
        g.1) With == operator : Returns true or false
        g.2) With eql? Operator : Returns true or false
        g.3) With casecmp method : Returns 0 if matched or 1 if not matched

7. Arrays : Ruby arrays are ordered collections of objects. They can hold objects like integer, number, hash, string, symbol or any other array.
    
    a) Creation of array : 
        a.1) Using literal constructor []
        a.2) Using new class method.
        Syntax : arr=Array.new
                or arr= Array.new(size) 
    b) length : To find the length of array.
        Syntax : <arr-name>.length
    c) Accessing array elements : using [] method
        Syntax : array-name[index];
    d) at method : To access a particular element, at method can also be used.
        Syntax : <arr-name>.at(index)
    e) fetch method : The fetch method is used to provide a default value error for out of array range indices.
        Syntax : <arr-name>.fetch(numbers,"default value")
    f) first and last method : The first and last method will return first and last element of an array respectively.
    g) take method : The take method returns the first n elements of an array.
    h) drop method : The drop method is the opposite of take method. It returns elements after n elements have been dropped.
    i) Adding items in array : 
        i.1) push or <<  -> at the end of an array
        i.2) unshift  -> front of array
        i.3) insert -> at particular index 
            Syntax : <arr-name>.insert(index,value)
    j) Remove items from array : To remove elements from an array.
        j.1) pop -> from end of an array
        j.2) shift   -> From start of an array
        j.3) delete  -> Delete from anywhere in an array.
            Syntax : <arr-name>.delete(value)
        j.4) uniq -> To remove duplicates from an array.
            Syntax : <arr-name>.uniq

8. Hashes : A hash is a collection of unique keys and their values. If a hash is accessed with a key that does not exist, the method will return nil.
    Syntax : <hash-name>={key1=>value1 , key2=>value2, ...}
                                or
            <hash-name>={key1:value1 , key2:value2 , ...}

9. Date and Time : Ruby has Mainly three classes related to date and time in its documentation.
    a) Date
    b) DateTime
    c) Time

10. Ranges : It represents a set of values with a beginning and an end. The ranges which has .. in them, run from beginning to end inclusively. The ranges which has ... in them, run exclusively the end value.
    Ruby has a variety of ways to define ranges.
    a) Ranges as sequences : The most natural way to define a range is in sequence. They have a start point and an end point. 
    b) Ranges as conditions : Ranges are also defined as conditional expressions. Different conditions are defined in a set of lines. These conditions are enclosed within start statement and end statement.
    c) Ranges as intervals : Intervals are represented by === case equality operator.
    d) Reverse range : Ruby reverse range operator does not return any value. We can use reverse function of ruby to reverse the range.

11. Iterators : Iterator is a concept used in object-oriented language. Iteration means doing one thing many times like a loop.
    a) Each Iterator :The Ruby each iterator returns all the elements from a hash or array.
        Syntax : (collection).each do |variable|
                    --code--
                 end
    b) Times Iterator : A loop is executed specified number of times by the times iterator. Loop will start from zero till one less than specified number.
        Syntax : x.times do |variable|
                    --code--
                 end
    c) Step Iterator : A step iterator is used to iterate while skipping over a range.
        Syntax : (controller).step(<step-count>) do |variable|
                    --code--
                 end
    d) Each line operator : A each_line iterator is used to iterate over a new line in a string.
        Syntax : <string with\n>.each_line do |variable|
                    --code--
                 end
    e) Upto Iterator : An upto iterator iterates from number x to number y.
        Syntax : x.upto(y) do |variable|
                    --code--
                 end
    f) Downto iterator : An downto iterator iterates from number y to number x.
        Syntax : y.downto(x) do |variable|
                    --code--
                 end
    
12. File I/O : Ruby I/O is a way to interact with your system. IO class is the basis for all input and output in Ruby. 
    Common modes in I/O port
    a) "r": read-only mode is the default mode starts at beginning of file.
    b) "r+": read-write mode, starts at beginning of file.
    c) "w": write-only mode, either creates a new file or truncates an existing file for writing.
    d) "w+": read-write mode, either creates a new file or truncates an existing file for reading and writing.
    e) "a": write-only mode, if file exists it will append the file othrwise a new file will be created for writing only.
    f) "a+": read and write mode, if file exists it will append the file othrwise a new file will be created for writing and reading.

    A) Opening a file : There are two methods to open a file in ruby.
    A.1) File.new method : Using this method a new file can be created for reading, writing or both.
        Syntax : f=File.new("filename.rb")

    A.2) File.open method : Using this method a new file object is created. That file object is assigned to a file.
        Syntax : File.open("filename.rb","mode") do |f|
    
    B) Reading a file : There are three different methods to read a file.
    B.1) To return a single line, following syntax is used.
        Syntax : f.gets
                 --code--
    B.2) To return the whole file after the current position.
        Syntax : f.read
                    --code--
    B.3) To return file as an array of lines
        Syntax : f.readlines  
                    --code--
    B.4) Sysread method : The sysread method is also used to read the content of a file. With the help of this method you can open a file in any mode.  

    C) Renaming and Deleting of a file : Ruby files are renamed using rename method and deleted using delete mehtod.
    C.1) Rename : Syntax : File.rename("olderName.txt", "newName.txt")  
    C.2) Delete : Syntax : File.delete("filename.txt")  

    D) Writing in a file : You can write content into a file. File needs to be opened in write mode for this method.

13. Directories : Class Dir has directory streams as objects which represents directories in underlying file system. Directories are handled with Dir class.
    
    a) Creating a directory : To create a directory mkdir command is used. You can give permission to a directory if you want (optional).
        Syntax: Dir.mkdir "directory-name",permission
    b) Checking directory : To check whether a directory exists or not exist? Method is used.
        Syntax : Dir.exist?"directory-name"
    c) Current working directory : To know the current working directory pwd method is used.
        Syntax : Dir.pwd
    d) Remove directory : To remove a directory, rmdir, unlink or delete methods are used. They perform same function for a Ruby directory.
        Syntax : Dir.rmdir "directory-name"

14. Exceptions : In a Ruby program, when something goes wrong, it throws an exceptional behavior. By default Ruby program terminates on throwing an exception.

15. OOPS Concept : Ruby is a true object oriented language which can be embedded into Hypertext Markup Language. Everything in Ruby is an object. OOPs is a programming concept that uses objects and their interactions to design applications and computer programs. There are four basic concepts in OOPS :

    a) Encapsulation: It hides the implementation details of a class from other objects due to which a class is unavailable to the rest of the code. Its main purpose is to protect data from data manipulation.

    b) Polymorphism: It is the ability to represent an operator or function in different ways for different data input.

    c) Inheritance: It creates new classes from pre defined classes. New class inherit behaviors of its parent class which is referred as superclass. In this way, pre defined classes can be made more reusable and useful.

    d) Abstraction: It hides the complexity of a class by modelling classes appropriate to the problem.

16. Constructor : A constructor is automatically called when an object is created. They do not return any values. In Ruby, they are called initialize.
    Syntax : class <ClassName>
                def initialize
                    --code--
                end
             end   